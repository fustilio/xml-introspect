/**
 * XSDAST Generator
 * 
 * Provides utilities for generating recursive and self-validating XSD schemas.
 */

import type { 
  EnhancedXSDASTNode, 
  RecursiveXSDGenerationOptions,
  XSDValidationRule
} from './types';
import { XSDASTNodeType } from './types';
import { XSDASTTraverser } from './traverser';
import { XSDHelper } from './helper';
import { XSDASTValidator } from './validator';

export class XSDRecursiveGenerator {
  private traverser: XSDASTTraverser;
  private helper: XSDHelper;
  private validator: XSDASTValidator;

  constructor(traverser: XSDASTTraverser) {
    this.traverser = traverser;
    this.helper = new XSDHelper(traverser);
    this.validator = new XSDASTValidator(traverser);
  }

  /**
   * Generate a recursive XSD schema that can validate itself
   */
  async generateRecursiveXSD(options: RecursiveXSDGenerationOptions): Promise<string> {
    const {
      targetNamespace,
      includeSelfValidation,
      maxRecursionDepth,
      generateComments,
      typeMappings = {},
      validationRules = []
    } = options;

    let xsd = '<?xml version="1.0" encoding="UTF-8"?>\n';
    
    if (generateComments) {
      xsd += '<!--\n';
      xsd += '  Recursive Self-Validating XSD Schema\n';
      xsd += '  Generated by xml-introspect XSDAST utilities\n';
      xsd += '  This schema can validate its own structure\n';
      xsd += '-->\n';
    }

    xsd += `<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"`;
    xsd += `\n           targetNamespace="${targetNamespace}"`;
    xsd += `\n           elementFormDefault="qualified"`;
    xsd += `\n           attributeFormDefault="unqualified">\n\n`;

    // Generate namespace declarations
    xsd += this.generateNamespaceDeclarations(targetNamespace, generateComments);

    // Generate the schema type definition (self-referencing)
    xsd += this.generateSchemaTypeDefinition(targetNamespace, generateComments);

    // Generate element definitions
    xsd += this.generateElementDefinitions(generateComments);

    // Generate complex type definitions
    xsd += this.generateComplexTypeDefinitions(generateComments);

    // Generate simple type definitions
    xsd += this.generateSimpleTypeDefinitions(generateComments);

    // Generate self-validation rules if requested
    if (includeSelfValidation) {
      xsd += this.generateSelfValidationRules(validationRules, generateComments);
    }

    // Generate recursive type definitions
    xsd += this.generateRecursiveTypeDefinitions(maxRecursionDepth, generateComments);

    xsd += '</xs:schema>';

    return xsd;
  }

  /**
   * Generate namespace declarations
   */
  private generateNamespaceDeclarations(targetNamespace: string, generateComments: boolean): string {
    let xsd = '';
    
    if (generateComments) {
      xsd += '  <!-- Namespace declarations -->\n';
    }

    xsd += `  <xs:import namespace="${targetNamespace}" schemaLocation="self.xsd"/>\n`;
    xsd += `  <xs:import namespace="http://www.w3.org/2001/XMLSchema" schemaLocation="http://www.w3.org/2001/XMLSchema.xsd"/>\n\n`;

    return xsd;
  }

  /**
   * Generate the schema type definition that references itself
   */
  private generateSchemaTypeDefinition(targetNamespace: string, generateComments: boolean): string {
    let xsd = '';
    
    if (generateComments) {
      xsd += '  <!-- Schema type definition (self-referencing) -->\n';
    }

    xsd += '  <xs:element name="schema" type="SchemaType"/>\n\n';
    xsd += '  <xs:complexType name="SchemaType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="element" type="ElementType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="complexType" type="ComplexTypeType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="simpleType" type="SimpleTypeType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="import" type="ImportType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="include" type="IncludeType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="targetNamespace" type="xs:anyURI" use="optional"/>\n';
    xsd += '    <xs:attribute name="elementFormDefault" type="FormChoice" use="optional"/>\n';
    xsd += '    <xs:attribute name="attributeFormDefault" type="FormChoice" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    return xsd;
  }

  /**
   * Generate element definitions
   */
  private generateElementDefinitions(generateComments: boolean): string {
    let xsd = '';
    
    if (generateComments) {
      xsd += '  <!-- Element type definitions -->\n';
    }

    xsd += '  <xs:complexType name="ElementType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="complexType" type="ComplexTypeType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="simpleType" type="SimpleTypeType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="name" type="xs:NCName" use="required"/>\n';
    xsd += '    <xs:attribute name="type" type="xs:QName" use="optional"/>\n';
    xsd += '    <xs:attribute name="minOccurs" type="OccursType" use="optional" default="1"/>\n';
    xsd += '    <xs:attribute name="maxOccurs" type="OccursType" use="optional" default="1"/>\n';
    xsd += '    <xs:attribute name="nillable" type="xs:boolean" use="optional" default="false"/>\n';
    xsd += '    <xs:attribute name="abstract" type="xs:boolean" use="optional" default="false"/>\n';
    xsd += '    <xs:attribute name="substitutionGroup" type="xs:QName" use="optional"/>\n';
    xsd += '    <xs:attribute name="final" type="DerivationSet" use="optional"/>\n';
    xsd += '    <xs:attribute name="block" type="DerivationSet" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    return xsd;
  }

  /**
   * Generate complex type definitions
   */
  private generateComplexTypeDefinitions(generateComments: boolean): string {
    let xsd = '';
    
    if (generateComments) {
      xsd += '  <!-- Complex type definitions -->\n';
    }

    xsd += '  <xs:complexType name="ComplexTypeType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="sequence" type="SequenceType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="choice" type="ChoiceType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="all" type="AllType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="attribute" type="AttributeType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="attributeGroup" type="AttributeGroupType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="name" type="xs:NCName" use="required"/>\n';
    xsd += '    <xs:attribute name="abstract" type="xs:boolean" use="optional" default="false"/>\n';
    xsd += '    <xs:attribute name="mixed" type="xs:boolean" use="optional" default="false"/>\n';
    xsd += '    <xs:attribute name="final" type="DerivationSet" use="optional"/>\n';
    xsd += '    <xs:attribute name="block" type="DerivationSet" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    return xsd;
  }

  /**
   * Generate simple type definitions
   */
  private generateSimpleTypeDefinitions(generateComments: boolean): string {
    let xsd = '';
    
    if (generateComments) {
      xsd += '  <!-- Simple type definitions -->\n';
    }

    xsd += '  <xs:complexType name="SimpleTypeType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="restriction" type="RestrictionType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="union" type="UnionType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="list" type="ListType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="name" type="xs:NCName" use="required"/>\n';
    xsd += '    <xs:attribute name="final" type="DerivationSet" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    return xsd;
  }

  /**
   * Generate self-validation rules
   */
  private generateSelfValidationRules(validationRules: XSDValidationRule[], generateComments: boolean): string {
    let xsd = '';
    
    if (generateComments) {
      xsd += '  <!-- Self-validation rules -->\n';
    }

    // Generate validation rules as XSD assertions
    for (const rule of validationRules) {
      xsd += `  <xs:assert test="${this.generateAssertionTest(rule)}">\n`;
      xsd += `    <xs:annotation>\n`;
      xsd += `      <xs:documentation>${rule.description}</xs:documentation>\n`;
      xsd += `    </xs:annotation>\n`;
      xsd += `  </xs:assert>\n\n`;
    }

    return xsd;
  }

  /**
   * Generate recursive type definitions
   */
  private generateRecursiveTypeDefinitions(maxDepth: number, generateComments: boolean): string {
    let xsd = '';
    
    if (generateComments) {
      xsd += '  <!-- Recursive type definitions -->\n';
    }

    // Generate sequence type
    xsd += '  <xs:complexType name="SequenceType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="element" type="ElementType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="sequence" type="SequenceType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="choice" type="ChoiceType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="all" type="AllType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="minOccurs" type="OccursType" use="optional" default="1"/>\n';
    xsd += '    <xs:attribute name="maxOccurs" type="OccursType" use="optional" default="1"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Generate choice type
    xsd += '  <xs:complexType name="ChoiceType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="element" type="ElementType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="sequence" type="SequenceType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="choice" type="ChoiceType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="all" type="AllType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="minOccurs" type="OccursType" use="optional" default="1"/>\n';
    xsd += '    <xs:attribute name="maxOccurs" type="OccursType" use="optional" default="1"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Generate all type
    xsd += '  <xs:complexType name="AllType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="element" type="ElementType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="minOccurs" type="OccursType" use="optional" default="1"/>\n';
    xsd += '    <xs:attribute name="maxOccurs" type="OccursType" use="optional" default="1"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Generate attribute type
    xsd += '  <xs:complexType name="AttributeType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="simpleType" type="SimpleTypeType" minOccurs="0"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="name" type="xs:NCName" use="required"/>\n';
    xsd += '    <xs:attribute name="type" type="xs:QName" use="optional"/>\n';
    xsd += '    <xs:attribute name="use" type="UseType" use="optional" default="optional"/>\n';
    xsd += '    <xs:attribute name="default" type="xs:string" use="optional"/>\n';
    xsd += '    <xs:attribute name="fixed" type="xs:string" use="optional"/>\n';
    xsd += '    <xs:attribute name="form" type="FormChoice" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Generate restriction type
    xsd += '  <xs:complexType name="RestrictionType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="enumeration" type="EnumerationType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="pattern" type="PatternType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="minLength" type="FacetType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="maxLength" type="FacetType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="minInclusive" type="FacetType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="maxInclusive" type="FacetType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="base" type="xs:QName" use="required"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Generate utility types
    xsd += this.generateUtilityTypes();

    return xsd;
  }

  /**
   * Generate utility types
   */
  private generateUtilityTypes(): string {
    let xsd = '';

    // Occurs type
    xsd += '  <xs:simpleType name="OccursType">\n';
    xsd += '    <xs:union memberTypes="xs:nonNegativeInteger">\n';
    xsd += '      <xs:simpleType>\n';
    xsd += '        <xs:restriction base="xs:string">\n';
    xsd += '          <xs:enumeration value="unbounded"/>\n';
    xsd += '        </xs:restriction>\n';
    xsd += '      </xs:simpleType>\n';
    xsd += '    </xs:union>\n';
    xsd += '  </xs:simpleType>\n\n';

    // Form choice
    xsd += '  <xs:simpleType name="FormChoice">\n';
    xsd += '    <xs:restriction base="xs:NMTOKEN">\n';
    xsd += '      <xs:enumeration value="qualified"/>\n';
    xsd += '      <xs:enumeration value="unqualified"/>\n';
    xsd += '    </xs:restriction>\n';
    xsd += '  </xs:simpleType>\n\n';

    // Use type
    xsd += '  <xs:simpleType name="UseType">\n';
    xsd += '    <xs:restriction base="xs:NMTOKEN">\n';
    xsd += '      <xs:enumeration value="optional"/>\n';
    xsd += '      <xs:enumeration value="required"/>\n';
    xsd += '      <xs:enumeration value="prohibited"/>\n';
    xsd += '    </xs:restriction>\n';
    xsd += '  </xs:simpleType>\n\n';

    // Derivation set
    xsd += '  <xs:simpleType name="DerivationSet">\n';
    xsd += '    <xs:list itemType="DerivationType"/>\n';
    xsd += '  </xs:simpleType>\n\n';

    xsd += '  <xs:simpleType name="DerivationType">\n';
    xsd += '    <xs:restriction base="xs:NMTOKEN">\n';
    xsd += '      <xs:enumeration value="extension"/>\n';
    xsd += '      <xs:enumeration value="restriction"/>\n';
    xsd += '      <xs:enumeration value="substitution"/>\n';
    xsd += '      <xs:enumeration value="list"/>\n';
    xsd += '      <xs:enumeration value="union"/>\n';
    xsd += '    </xs:restriction>\n';
    xsd += '  </xs:simpleType>\n\n';

    // Facet type
    xsd += '  <xs:complexType name="FacetType">\n';
    xsd += '    <xs:attribute name="value" type="xs:string" use="required"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Enumeration type
    xsd += '  <xs:complexType name="EnumerationType">\n';
    xsd += '    <xs:attribute name="value" type="xs:string" use="required"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Pattern type
    xsd += '  <xs:complexType name="PatternType">\n';
    xsd += '    <xs:attribute name="value" type="xs:string" use="required"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Union type
    xsd += '  <xs:complexType name="UnionType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="simpleType" type="SimpleTypeType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="memberTypes" type="xs:QName" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // List type
    xsd += '  <xs:complexType name="ListType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="simpleType" type="SimpleTypeType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="itemType" type="xs:QName" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Attribute group type
    xsd += '  <xs:complexType name="AttributeGroupType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="attribute" type="AttributeType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="attributeGroup" type="AttributeGroupType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="name" type="xs:NCName" use="optional"/>\n';
    xsd += '    <xs:attribute name="ref" type="xs:QName" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Import type
    xsd += '  <xs:complexType name="ImportType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="namespace" type="xs:anyURI" use="optional"/>\n';
    xsd += '    <xs:attribute name="schemaLocation" type="xs:anyURI" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Include type
    xsd += '  <xs:complexType name="IncludeType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="annotation" type="AnnotationType" minOccurs="0"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="schemaLocation" type="xs:anyURI" use="required"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // Annotation type
    xsd += '  <xs:complexType name="AnnotationType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:element name="documentation" type="DocumentationType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '      <xs:element name="appinfo" type="AppInfoType" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '  </xs:complexType>\n\n';

    // Documentation type
    xsd += '  <xs:complexType name="DocumentationType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="source" type="xs:anyURI" use="optional"/>\n';
    xsd += '    <xs:attribute name="xml:lang" type="xs:language" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    // App info type
    xsd += '  <xs:complexType name="AppInfoType">\n';
    xsd += '    <xs:sequence>\n';
    xsd += '      <xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>\n';
    xsd += '    </xs:sequence>\n';
    xsd += '    <xs:attribute name="source" type="xs:anyURI" use="optional"/>\n';
    xsd += '  </xs:complexType>\n\n';

    return xsd;
  }

  /**
   * Generate assertion test for a validation rule
   */
  private generateAssertionTest(rule: XSDValidationRule): string {
    // This is a simplified implementation
    // In a real implementation, you would need to convert the rule implementation
    // to XPath expressions
    switch (rule.name) {
      case 'schema-target-namespace':
        return '@targetNamespace';
      case 'element-name-required':
        return '@name';
      case 'complex-type-name-required':
        return '@name';
      case 'simple-type-name-required':
        return '@name';
      case 'attribute-name-required':
        return '@name';
      case 'min-occurs-non-negative':
        return 'not(@minOccurs) or @minOccurs >= 0';
      case 'max-occurs-valid':
        return 'not(@maxOccurs) or @maxOccurs > 0 or @maxOccurs = "unbounded"';
      case 'max-occurs-gte-min-occurs':
        return 'not(@maxOccurs) or not(@minOccurs) or @maxOccurs = "unbounded" or @maxOccurs >= @minOccurs';
      default:
        return 'true()';
    }
  }

  /**
   * Generate a self-validating XSD from an existing XSD AST
   */
  async generateFromExistingXSD(options: RecursiveXSDGenerationOptions): Promise<string> {
    const existingXSD = this.traverser.getRoot();
    
    // Analyze the existing XSD structure
    const analysis = this.analyzeXSDStructure(existingXSD);
    
    // Generate the recursive XSD based on the analysis
    return this.generateRecursiveXSD({
      ...options,
      typeMappings: {
        ...options.typeMappings,
        ...analysis.typeMappings
      }
    });
  }

  /**
   * Analyze XSD structure for generation
   */
  private analyzeXSDStructure(root: EnhancedXSDASTNode): {
    typeMappings: Record<string, string>;
    elementCount: number;
    complexTypeCount: number;
    simpleTypeCount: number;
    attributeCount: number;
  } {
    const typeMappings: Record<string, string> = {};
    let elementCount = 0;
    let complexTypeCount = 0;
    let simpleTypeCount = 0;
    let attributeCount = 0;

    this.traverser.traverse((node) => {
      switch (node.type) {
        case XSDASTNodeType.ELEMENT:
          elementCount++;
          if (node.attributes.type) {
            typeMappings[node.name || ''] = node.attributes.type;
          }
          break;
        case XSDASTNodeType.COMPLEX_TYPE:
          complexTypeCount++;
          break;
        case XSDASTNodeType.SIMPLE_TYPE:
          simpleTypeCount++;
          break;
        case XSDASTNodeType.ATTRIBUTE:
          attributeCount++;
          break;
      }
    });

    return {
      typeMappings,
      elementCount,
      complexTypeCount,
      simpleTypeCount,
      attributeCount
    };
  }

  /**
   * Validate the generated recursive XSD
   */
  async validateGeneratedXSD(xsdContent: string): Promise<boolean> {
    // This would typically involve parsing the generated XSD and validating it
    // For now, we'll do a basic syntax check
    try {
      // Basic XML syntax validation
      if (!xsdContent.includes('<?xml version="1.0"')) {
        return false;
      }
      if (!xsdContent.includes('<xs:schema')) {
        return false;
      }
      if (!xsdContent.includes('</xs:schema>')) {
        return false;
      }
      
      // Check for self-referencing elements
      if (!xsdContent.includes('type="SchemaType"')) {
        return false;
      }
      
      return true;
    } catch (error) {
      return false;
    }
  }
}
